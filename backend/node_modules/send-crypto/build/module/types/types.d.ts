import BigNumber from "bignumber.js";
import { PromiEvent } from "../lib/promiEvent";
export declare type Asset = string | object;
export declare type Value = string | number | BigNumber | {
    toString: () => string;
};
export interface DeferHandler<Options = {}> {
    readonly address: (asset: Asset, options?: any & {}) => Promise<string>;
    readonly getBalance: (asset: Asset, options?: any & {
        readonly address?: string;
    }) => Promise<BigNumber>;
    readonly getBalanceInSats: (asset: Asset, options?: any & {
        readonly address?: string;
    }) => Promise<BigNumber>;
    readonly send: (to: string, value: BigNumber, asset: Asset, options?: Options) => PromiEvent<string>;
    readonly sendSats: (to: string, value: BigNumber, asset: Asset, options?: Options) => PromiEvent<string>;
}
export declare abstract class Handler<ConstructorOptions = {}, AddressOptions = {}, BalanceOptions extends {
    address?: string;
} = {
    address?: string;
}, TxOptions = {}> {
    constructor(_privateKey: string, _network: string, _constructorOptions?: ConstructorOptions, _sharedState?: any);
    handlesAsset: (asset: Asset) => boolean;
    address?: (asset: Asset, options: AddressOptions, deferHandler: DeferHandler) => Promise<string>;
    getBalance?: (asset: Asset, options: BalanceOptions, deferHandler: DeferHandler) => Promise<BigNumber>;
    getBalanceInSats?: (asset: Asset, options: BalanceOptions, deferHandler: DeferHandler) => Promise<BigNumber>;
    send?: (to: string, value: BigNumber, asset: Asset, options: TxOptions, deferHandler: DeferHandler) => PromiEvent<string>;
    sendSats?: (to: string, value: BigNumber, asset: Asset, options: TxOptions, deferHandler: DeferHandler) => PromiEvent<string>;
}
export declare type HandlerClass = new <Options extends {}>(privateKey: string, network: string, constructorOptions?: Options, sharedState?: any) => Handler;
