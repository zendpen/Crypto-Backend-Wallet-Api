/// <reference types="node" />
/**
 * @file PromiEvent.js
 * @author Fabian Vogelsteller <fabian@ethereum.org>, Samuel Furter <samuel@ethereum.org>
 * @date 2018
 */
import { EventEmitter } from "events";
declare class InternalPromiEvent<T> {
    readonly [Symbol.toStringTag]: "Promise";
    readonly promise: Promise<T>;
    resolve: (value?: T) => void;
    reject: (reason?: any) => void;
    readonly eventEmitter: EventEmitter;
    readonly emit: EventEmitter["emit"];
    readonly removeListener: EventEmitter["removeListener"];
    readonly on: (event: string, callback: (...values: readonly any[]) => void | Promise<void>) => this;
    readonly once: (event: string, callback: (...values: readonly any[]) => void | Promise<void>) => this;
    readonly then: Promise<T>["then"];
    readonly catch: Promise<T>["catch"];
    readonly finally: Promise<T>["finally"];
    readonly listeners: EventEmitter["listeners"];
    readonly eventNames: EventEmitter["eventNames"];
    /**
     * @constructor
     */
    constructor();
    /**
     * Proxy handler to call the promise or eventEmitter methods
     */
    proxyHandler(target: PromiEvent<T>, name: string): any;
}
export declare type PromiEvent<T> = InternalPromiEvent<T> & Promise<T>;
export declare const newPromiEvent: <T>() => PromiEvent<T>;
export declare const forwardEvents: <T, Y>(src: PromiEvent<T>, dest: PromiEvent<Y>, filterFn?: (_name: string) => boolean) => void;
export {};
