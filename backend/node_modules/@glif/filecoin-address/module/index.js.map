{"version":3,"sources":["../src/index.js"],"names":["leb","require","blake2b","base32Function","base32","newAddress","newFromString","decode","encode","bigintToArray","getChecksum","validateChecksum","validateAddressString","checkAddressString","Address","constructor","str","length","Error","slice","v","tmp","BigInt","toString","Buffer","from","ingest","expect","digest","compare","protocol","payload","protocolByte","alloc","concat","address","network","raw","substring","unsigned","payloadChecksum","checksum","addressObj","addressString","String","bytes","string","error","module","exports"],"mappings":"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","sourcesContent":["/* eslint-disable radix,prefer-const */\nconst leb = require('leb128')\nconst { blake2b } = require('blakejs')\nconst base32Function = require('./base32')\n\nconst base32 = base32Function('abcdefghijklmnopqrstuvwxyz234567')\n\nlet newAddress\nlet newFromString\nlet decode\nlet encode\nlet bigintToArray\nlet getChecksum\nlet validateChecksum\nlet validateAddressString\nlet checkAddressString\n\nclass Address {\n  constructor(str) {\n    if (!str || str.length < 1) throw new Error('Missing str in address')\n    this.str = str\n  }\n\n  protocol = () => {\n    if (this.str.length < 1) {\n      return Error('No address found.')\n    }\n    return this.str[0]\n  }\n\n  payload = () => {\n    if (this.str.length < 1) {\n      return Error('No address found.')\n    }\n    return this.str.slice(1, this.str.length)\n  }\n}\n\nbigintToArray = v => {\n  // eslint-disable-next-line no-undef\n  let tmp = BigInt(v).toString(16)\n  if (tmp.length % 2 === 1) tmp = `0${tmp}`\n  return Buffer.from(tmp, 'hex')\n}\n\ngetChecksum = ingest => {\n  return blake2b(ingest, null, 4)\n}\n\nvalidateChecksum = (ingest, expect) => {\n  const digest = getChecksum(ingest)\n  return Buffer.compare(Buffer.from(digest), expect)\n}\n\nnewAddress = (protocol, payload) => {\n  const protocolByte = new Buffer.alloc(1)\n  protocolByte[0] = protocol\n\n  return new Address(Buffer.concat([protocolByte, payload]))\n}\n\ndecode = address => {\n  checkAddressString(address)\n\n  const network = address.slice(0, 1)\n  const protocol = address.slice(1, 2)\n  const protocolByte = new Buffer.alloc(1)\n  protocolByte[0] = protocol\n  const raw = address.substring(2, address.length)\n\n  if (protocol === '0') {\n    return newAddress(protocol, Buffer.from(leb.unsigned.encode(raw)))\n  }\n\n  const payloadChecksum = new Buffer.from(base32.decode(raw))\n  const { length } = payloadChecksum\n  const payload = payloadChecksum.slice(0, length - 4)\n  const checksum = payloadChecksum.slice(length - 4, length)\n  if (validateChecksum(Buffer.concat([protocolByte, payload]), checksum)) {\n    throw Error(\"Checksums don't match\")\n  }\n\n  const addressObj = newAddress(protocol, payload)\n  if (encode(network, addressObj) !== address)\n    throw Error(`Did not encode this address properly: ${address}`)\n\n  return addressObj\n}\n\nencode = (network, address) => {\n  if (!address || !address.str) throw Error('Invalid address')\n  let addressString = ''\n  const payload = address.payload()\n\n  switch (address.protocol()) {\n    case 0: {\n      addressString =\n        network +\n        String(address.protocol()) +\n        leb.unsigned.decode(address.payload())\n      break\n    }\n    default: {\n      const protocolByte = new Buffer.alloc(1)\n      protocolByte[0] = address.protocol()\n      const checksum = getChecksum(Buffer.concat([protocolByte, payload]))\n      const bytes = Buffer.concat([payload, Buffer.from(checksum)])\n      addressString =\n        String(network) + String(address.protocol()) + base32.encode(bytes)\n      break\n    }\n  }\n\n  return addressString\n}\n\nnewFromString = address => {\n  return decode(address)\n}\n\nvalidateAddressString = string => {\n  try {\n    checkAddressString(string)\n    return true\n  } catch (error) {\n    return false\n  }\n}\n\ncheckAddressString = address => {\n  if (!address) throw Error('No bytes to validate.')\n  if (address.length < 3) throw Error('Address is too short to validate.')\n  if (address[0] !== 'f' && address[0] !== 't') {\n    throw Error('Unknown address network.')\n  }\n\n  switch (address[1]) {\n    case '0': {\n      if (address.length > 22) throw Error('Invalid ID address length.')\n      break\n    }\n    case '1': {\n      if (address.length !== 41)\n        throw Error('Invalid secp256k1 address length.')\n      break\n    }\n    case '2': {\n      if (address.length !== 41) throw Error('Invalid Actor address length.')\n      break\n    }\n    case '3': {\n      if (address.length !== 86) throw Error('Invalid BLS address length.')\n      break\n    }\n    default: {\n      throw new Error('Invalid address protocol.')\n    }\n  }\n}\n\nmodule.exports = {\n  Address,\n  newAddress,\n  newFromString,\n  bigintToArray,\n  decode,\n  encode,\n  getChecksum,\n  validateChecksum,\n  validateAddressString,\n  checkAddressString\n}\n"],"file":"index.js"}