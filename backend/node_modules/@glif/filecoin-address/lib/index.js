function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/* eslint-disable radix,prefer-const */
var leb = require('leb128');

var _require = require('blakejs'),
    blake2b = _require.blake2b;

var base32Function = require('./base32');

var base32 = base32Function('abcdefghijklmnopqrstuvwxyz234567');
var newAddress;
var newFromString;
var decode;
var encode;
var bigintToArray;
var getChecksum;
var validateChecksum;
var validateAddressString;
var checkAddressString;

var Address = function Address(str) {
  var _this = this;

  _classCallCheck(this, Address);

  _defineProperty(this, "protocol", function () {
    if (_this.str.length < 1) {
      return Error('No address found.');
    }

    return _this.str[0];
  });

  _defineProperty(this, "payload", function () {
    if (_this.str.length < 1) {
      return Error('No address found.');
    }

    return _this.str.slice(1, _this.str.length);
  });

  if (!str || str.length < 1) throw new Error('Missing str in address');
  this.str = str;
};

bigintToArray = function bigintToArray(v) {
  // eslint-disable-next-line no-undef
  var tmp = BigInt(v).toString(16);
  if (tmp.length % 2 === 1) tmp = "0".concat(tmp);
  return Buffer.from(tmp, 'hex');
};

getChecksum = function getChecksum(ingest) {
  return blake2b(ingest, null, 4);
};

validateChecksum = function validateChecksum(ingest, expect) {
  var digest = getChecksum(ingest);
  return Buffer.compare(Buffer.from(digest), expect);
};

newAddress = function newAddress(protocol, payload) {
  var protocolByte = new Buffer.alloc(1);
  protocolByte[0] = protocol;
  return new Address(Buffer.concat([protocolByte, payload]));
};

decode = function decode(address) {
  checkAddressString(address);
  var network = address.slice(0, 1);
  var protocol = address.slice(1, 2);
  var protocolByte = new Buffer.alloc(1);
  protocolByte[0] = protocol;
  var raw = address.substring(2, address.length);

  if (protocol === '0') {
    return newAddress(protocol, Buffer.from(leb.unsigned.encode(raw)));
  }

  var payloadChecksum = new Buffer.from(base32.decode(raw));
  var length = payloadChecksum.length;
  var payload = payloadChecksum.slice(0, length - 4);
  var checksum = payloadChecksum.slice(length - 4, length);

  if (validateChecksum(Buffer.concat([protocolByte, payload]), checksum)) {
    throw Error("Checksums don't match");
  }

  var addressObj = newAddress(protocol, payload);
  if (encode(network, addressObj) !== address) throw Error("Did not encode this address properly: ".concat(address));
  return addressObj;
};

encode = function encode(network, address) {
  if (!address || !address.str) throw Error('Invalid address');
  var addressString = '';
  var payload = address.payload();

  switch (address.protocol()) {
    case 0:
      {
        addressString = network + String(address.protocol()) + leb.unsigned.decode(address.payload());
        break;
      }

    default:
      {
        var protocolByte = new Buffer.alloc(1);
        protocolByte[0] = address.protocol();
        var checksum = getChecksum(Buffer.concat([protocolByte, payload]));
        var bytes = Buffer.concat([payload, Buffer.from(checksum)]);
        addressString = String(network) + String(address.protocol()) + base32.encode(bytes);
        break;
      }
  }

  return addressString;
};

newFromString = function newFromString(address) {
  return decode(address);
};

validateAddressString = function validateAddressString(string) {
  try {
    checkAddressString(string);
    return true;
  } catch (error) {
    return false;
  }
};

checkAddressString = function checkAddressString(address) {
  if (!address) throw Error('No bytes to validate.');
  if (address.length < 3) throw Error('Address is too short to validate.');

  if (address[0] !== 'f' && address[0] !== 't') {
    throw Error('Unknown address network.');
  }

  switch (address[1]) {
    case '0':
      {
        if (address.length > 22) throw Error('Invalid ID address length.');
        break;
      }

    case '1':
      {
        if (address.length !== 41) throw Error('Invalid secp256k1 address length.');
        break;
      }

    case '2':
      {
        if (address.length !== 41) throw Error('Invalid Actor address length.');
        break;
      }

    case '3':
      {
        if (address.length !== 86) throw Error('Invalid BLS address length.');
        break;
      }

    default:
      {
        throw new Error('Invalid address protocol.');
      }
  }
};

module.exports = {
  Address: Address,
  newAddress: newAddress,
  newFromString: newFromString,
  bigintToArray: bigintToArray,
  decode: decode,
  encode: encode,
  getChecksum: getChecksum,
  validateChecksum: validateChecksum,
  validateAddressString: validateAddressString,
  checkAddressString: checkAddressString
};
//# sourceMappingURL=index.js.map